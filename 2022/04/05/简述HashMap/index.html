<!DOCTYPE html>
<html lang="en_US">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="HashMap"/>




  <meta name="keywords" content="Java, Enen" />










  <link rel="alternate" href="/atom.xml" title="Enen" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0" />



<link rel="canonical" href="https://fengqisheng.cn/2022/04/05/简述HashMap/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0" />



  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f5ca945276d7d2f5e5618b24909a515";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"since":2022,"favicon":"/favicon.ico","footer":null,"counter":true,"menu":{"主页":"/","归档":"/archives/","标签":"/tags","分类":"/categories","关于":"/about"},"theme":{"color":"Cobalt Blue"},"toc":true,"languages":"en_US","fancybox":true,"pjax":true,"copyright":{"enable":true,"license":"CC BY-NC-SA 3.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/3.0/"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"cursor_effect":{"enabled":true,"type":"cherry"},"social":{"email":"2250377639@qq.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/evenff","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":null,"enable":true,"app_id":"VD1Yyn63Jw03Fo3HTECjPyBz-gzGzoHsz","app_key":"G9A2LTwQsuSb5MWnnNiaWTN9","security":false,"betterPerformance":false,"baidu_analytics":"6f5ca945276d7d2f5e5618b24909a515","baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":null,"changyan":{"appid":null,"appkey":null},"passage_end_tag":{"enabled":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"livere_datauid":"MTAyMC81NjYzMC8zMzA5Mw","version":"2.9.0"};
</script>

    <title> HashMap - Enen </title>
  <meta name="generator" content="Hexo 6.1.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Enen</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            主页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Enen</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              主页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          HashMap
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-04-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E7%9A%84%E9%82%A3%E4%BA%9B%E6%95%85%E4%BA%8B"><span class="toc-text">HashMap的那些故事</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.HashMap的底层数据结构是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.说一下HashMap的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-HashMap%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="toc-text">3. 解决hash冲突的办法有哪些?HashMap用的哪种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E64%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%93%BE%E8%A1%A8%E6%89%8D%E4%BC%9A%E8%BF%9B%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">4.为什么要在数组长度大于64之后，链表才会进化为红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%AE%BE%E7%BD%AE%E4%B8%BA0-75%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%B4%E7%95%8C%E5%80%BC%E6%98%AF12%EF%BC%9F"><span class="toc-text">5.为什么加载因子设置为0.75，初始化临界值是12？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E4%BD%95%E7%A7%8D%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97hash%E5%80%BC%EF%BC%9F%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%A1%E7%AE%97%E5%87%BAhash%E5%80%BC%EF%BC%9F"><span class="toc-text">6. 哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E7%9B%B8%E7%AD%89%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-text">7. 当两个对象的hashCode相等时会怎样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%95%E6%97%B6%E5%8F%91%E7%94%9F%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E5%92%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E-%EF%BC%9F"><span class="toc-text">8. 何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞****？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">9. HashMap的put方法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F"><span class="toc-text">10. HashMap的扩容方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key%EF%BC%9F"><span class="toc-text">11. 一般用什么作为HashMap的key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88Map%E6%A1%B6%E4%B8%AD%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E8%B6%85%E8%BF%878%E6%89%8D%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-text">12. 为什么Map桶中节点个数超过8才转为红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">13. HashMap为什么线程不安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%AE%A1%E7%AE%97hash%E5%80%BC%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A9%E4%BD%8E16bit%E5%92%8C%E9%AB%9816bit%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E5%A4%84%E7%90%86"><span class="toc-text">14. 计算hash值时为什么要让低16bit和高16bit进行异或处理</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>简述HashMap底层及扩容</p>
<span id="more"></span>

<h1 id="HashMap的那些故事"><a href="#HashMap的那些故事" class="headerlink" title="HashMap的那些故事"></a>HashMap的那些故事</h1><h3 id="1-HashMap的底层数据结构是什么"><a href="#1-HashMap的底层数据结构是什么" class="headerlink" title="1.HashMap的底层数据结构是什么"></a>1.HashMap的底层数据结构是什么</h3><p><img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/48540923dd54564e59c64185e18b6a84d0584f43.png"></p>
<p>在JDK1.7中和JDK1.8中的区别</p>
<ol>
<li><p>JDK1.7 是由“数组+链表”组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>注：哈希冲突下方说明，标题3。</p>
</li>
<li><p>在JDK1.8中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响HashMap的性能，红黑树搜索时间复杂度是O（logn），链表是O（n）。因此，JDK1.8对数据结构做了进一步的优化，引入红黑树，链表和红黑树在达到一定条件下会进行转换：</p>
</li>
</ol>
<ul>
<li>当链表超过8且数组长度（数据总量）超过64才会转为红黑树</li>
<li>将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行扩容，而不是转换为红黑树，以减少搜索时间</li>
</ul>
<p><img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/48540923dd54564e59c64185e18b6a84d0584f43.png"></p>
<p><img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405181503798.png"></p>
<h3 id="2-说一下HashMap的特点"><a href="#2-说一下HashMap的特点" class="headerlink" title="2.说一下HashMap的特点"></a>2.说一下HashMap的特点</h3><ul>
<li>HashMap存取是无序的</li>
<li>键和值位置都可以是null，但是键位置只能是一个null</li>
<li>键位置是唯一的，底层的数据结构是控制键的</li>
<li>阈值（边界值）&gt; 8 并且数组长度大于64，才将链表转换成红黑树，变成红黑树的目的是提高搜索速度，高效查询</li>
</ul>
<h3 id="3-解决hash冲突的办法有哪些-HashMap用的哪种？"><a href="#3-解决hash冲突的办法有哪些-HashMap用的哪种？" class="headerlink" title="3. 解决hash冲突的办法有哪些?HashMap用的哪种？"></a>3. <strong>解决hash冲突的办法有哪些?HashMap用的哪种？</strong></h3><p>  解决Hash冲突方法有：开放定址法、再哈希法、链地址法（HashMap中常见的拉链法）、简历公共溢出区。HashMap中采用的是链地址法。</p>
<ul>
<li>开放定址法也称为再散列法，基本思想就是，如果p&#x3D;H(key)出现冲突时，则以p为基础，再次hash，p1&#x3D;H(p)，如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点</li>
<li>再哈希法（双重散列，多重散列），提供多个不同的hash函数，R1&#x3D;H1(key1)发生冲突时，再计算R2&#x3D;H2（key1），直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。</li>
<li>链地址法（拉链法），将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行，链表法适用于经常进行插入和删除的情况。</li>
<li>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区</li>
</ul>
<p>  注意开放定址法和再哈希法的区别是</p>
<ul>
<li>开放定址法只能使用同一种hash函数进行再次hash，再哈希法可以调用多种不同的hash函数进行再次hash</li>
</ul>
<h3 id="4-为什么要在数组长度大于64之后，链表才会进化为红黑树"><a href="#4-为什么要在数组长度大于64之后，链表才会进化为红黑树" class="headerlink" title="4.为什么要在数组长度大于64之后，链表才会进化为红黑树"></a><strong>4.为什么要在数组长度大于64之后，链表才会进化为红黑树</strong></h3><p>  ​       在数组比较小时如果出现红黑树结构，反而会降低效率，而红黑树需要进行左旋右旋，变色，这些操作来保持平衡；同时数组长度小于64时，搜索时间相对要快一些，总之是为了加快搜索速度，提高性能</p>
<p>  ​       JDK1.8以前HashMap的实现是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放在同一个桶中时，这个桶下有一条长长的链表，此时HashMap就相当于单链表，假如单链表有n个元素，遍历的时间复杂度就从O（1）退化成O（n），完全失去了它的优势，为了解决此种情况，JDK1.8中引入了红黑树（查找的时间复杂度为O（logn））来优化这种问题</p>
<h3 id="5-为什么加载因子设置为0-75，初始化临界值是12？"><a href="#5-为什么加载因子设置为0-75，初始化临界值是12？" class="headerlink" title="5.为什么加载因子设置为0.75，初始化临界值是12？"></a><strong>5.为什么加载因子设置为0.75，初始化临界值是12？</strong></h3><p>  ​         HashMap中的threshold是HashMap所能容纳键值对的最大值。计算公式为length*LoadFactory。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数也越大</p>
<p>  ​      loadFactory越趋近于1，那么数组中存放的数据（entry也就越来越多），数据也就越密集，也就会有更多的链表长度处于更长的数值，我们的查询效率就会越低，当我们添加数据，产生hash冲突的概率也会更高</p>
<p>  ​      默认的loadFactory是0.75，loadFactory越小，越趋近于0，数组中个存放的数据(entry)也就越少，表现得更加稀疏</p>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405183227653.png"></p>
<p>  0.75是对空间和时间效率的一种平衡选择</p>
<p>  如果负载因子小一些比如是0.4，那么初始长度16*0.4&#x3D;6，数组占满6个空间就进行扩容，很多空间可能元素很少甚至没有元素，会造成大量的空间被浪费</p>
<p>  如果负载因子大一些比如是0.9，这样会导致扩容之前查找元素的效率非常低</p>
<p>  loadfactory设置为0.75是经过多重计算检验得到的可靠值，可以最大程度的减少rehash的次数，避免过多的性能消耗</p>
<h3 id="6-哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？"><a href="#6-哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？" class="headerlink" title="6. 哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？"></a><strong>6. 哈希表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？</strong></h3><p>  ​      hashCode方法是Object中的方法，所有的类都可以对其进行使用，首先底层通过调用hashCode方法生成初始hash值h1，然后将h1无符号右移16位得到h2，之后将h1与h2进行按位异或（^）运算得到最终hash值h3，之后将h3与(length-1)进行按位与（&amp;）运算得到hash表索引</p>
<p>  其他可以计算出hash值的算法有</p>
<ul>
<li>平方取中法</li>
<li>取余数</li>
<li>伪随机数法</li>
</ul>
<h3 id="7-当两个对象的hashCode相等时会怎样"><a href="#7-当两个对象的hashCode相等时会怎样" class="headerlink" title="7. 当两个对象的hashCode相等时会怎样"></a><strong>7. 当两个对象的hashCode相等时会怎样</strong></h3><p>  ​     hashCode相等产生hash碰撞，hashCode相等会调用equals方法比较内容是否相等，内容如果相等则会进行覆盖，内容如果不等则会连接到链表后方，链表长度超过8且数组长度超过64，会转变成红黑树节点</p>
<h3 id="8-何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞-？"><a href="#8-何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞-？" class="headerlink" title="8. 何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞****？"></a><strong>8. 何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞****？</strong></h3><p>  只要两个元素的key计算的hash码值相同就会发生hash碰撞，jdk8之前使用链表解决哈希碰撞，jdk8之后使用链表+红黑树解决哈希碰撞</p>
<h3 id="9-HashMap的put方法流程"><a href="#9-HashMap的put方法流程" class="headerlink" title="9. HashMap的put方法流程"></a><strong>9. HashMap的put方法流程</strong></h3><p>  以jdk8为例，简要流程如下：</p>
<ul>
<li>首先根据key的值计算hash值，找到该元素在数组中存储的下标</li>
<li>如果数组是空的，则调用resize进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里</li>
<li>如果冲突了，且key已经存在，就覆盖掉value</li>
<li>如果冲突后是链表结构，就判断该链表是否大于8，如果大于8并且数组容量小于64，就进行扩容；如果链表节点数量大于8并且数组的容量大于64，则将这个结构转换成红黑树；否则，链表插入键值对，若key存在，就覆盖掉value</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上</li>
</ul>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405183453637.png"></p>
<h3 id="10-HashMap的扩容方式"><a href="#10-HashMap的扩容方式" class="headerlink" title="10. HashMap的扩容方式"></a><strong>10. HashMap的扩容方式</strong></h3><p>  HashMap在容量超过负载因子所定义的容量之后，就会扩容。java里的数组是无法自己扩容的，将HashMap的大小扩大为原来数组的两倍</p>
<p>  我们来看jdk1.8扩容的源码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//oldTab：引用扩容前的哈希表</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//oldCap：表示扩容前的table数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//获得旧哈希表的扩容阈值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="comment">//newCap:扩容之后table数组大小</span></span><br><span class="line">        <span class="comment">//newThr:扩容之后下次触发扩容的条件</span></span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//条件成立说明hashMap中的散列表已经初始化过了，是一次正常扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断旧的容量是否大于等于最大容量，如果是，则无法扩容，并且设置扩容条件为int最大值，</span></span><br><span class="line">            <span class="comment">//这种情况属于非常少数的情况</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;<span class="comment">//设置newCap新容量为oldCap旧容量的二倍（&lt;&lt;1）,并且&lt;最大容量，而且&gt;=16，则新阈值等于旧阈值的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果oldCap=0并且边界值大于0，说明散列表是null，但此时oldThr&gt;0</span></span><br><span class="line">        <span class="comment">//说明此时hashMap的创建是通过指定的构造方法创建的,新容量直接等于阈值</span></span><br><span class="line">        <span class="comment">//1.new HashMap(intitCap,loadFactor)</span></span><br><span class="line">        <span class="comment">//2.new HashMap(initCap)</span></span><br><span class="line">        <span class="comment">//3.new HashMap(map)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//这种情况下oldThr=0;oldCap=0，说明没经过初始化，创建hashMap</span></span><br><span class="line">        <span class="comment">//的时候是通过new HashMap()的方式创建的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//newThr为0时，通过newCap和loadFactor计算出一个newThr</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//容量*0.75</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">                <span class="comment">//根据上面计算出的结果创建一个更长更大的数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        <span class="comment">//将table指向新创建的数组</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">//本次扩容之前table不为null</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对数组中的元素进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//设置e为当前node节点</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//当前桶位数据不为空，但不能知道里面是单个元素，还是链表或红黑树，</span></span><br><span class="line">                <span class="comment">//e = oldTab[j]，先用e记录下当前元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将老数组j桶位置为空，方便回收</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//如果e节点不存在下一个节点，说明e是单个元素，则直接放置在新数组的桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//如果e是树节点，证明该节点处于红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//e为链表节点，则对链表进行遍历</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//低位链表：存放在扩容之后的数组的下标位置，与当前数组下标位置一致</span></span><br><span class="line">                        <span class="comment">//loHead：低位链表头节点</span></span><br><span class="line">                        <span class="comment">//loTail低位链表尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//高位链表，存放扩容之后的数组的下标位置，=原索引+扩容之前数组容量</span></span><br><span class="line">                        <span class="comment">//hiHead:高位链表头节点</span></span><br><span class="line">                        <span class="comment">//hiTail:高位链表尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//oldCap为16:10000，与e.hsah做&amp;运算可以得到高位为1还是0</span></span><br><span class="line">                            <span class="comment">//高位为0，放在低位链表</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//loHead指向e</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//高位为1，放在高位链表</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位链表已成，将头节点loHead指向在原位</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位链表已成，将头节点指向新索引</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  扩容之后原位置的节点只有两种调整</p>
<ul>
<li>保持原位置不动（新bit位为0时）</li>
<li>散列原索引+扩容大小的位置去（新bit位为1时）</li>
</ul>
<p>  扩容之后元素的散列设置的非常巧妙，节省了计算hash值的时间，我们来看一 下具体的实现</p>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405183635630.png"></p>
<p>  当数组长度从16到32，其实只是多了一个bit位的运算，我们只需要在意那个多出来的bit为是0还是1，是0的话索引不变，是1的话索引变为当前索引值+扩容的长度，比如5变成5+16&#x3D;21</p>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405183726616.png"></p>
<p>  这样的扩容方式不仅节省了重新计算hash的时间，而且保证了当前桶中的元素总数一定小于等于原来桶中的元素数量，避免了更严重的hash冲突，均匀的把之前冲突的节点分散到新的桶中去</p>
<h3 id="11-一般用什么作为HashMap的key？"><a href="#11-一般用什么作为HashMap的key？" class="headerlink" title="11. 一般用什么作为HashMap的key？"></a><strong>11. 一般用什么作为HashMap的key？</strong></h3><p>  一般用Integer、String这种不可变类当HashMap当key</p>
<ul>
<li>因为String是不可变的，当创建字符串时，它的hashcode被缓存下来，不需要再次计算，相对于其他对象更快</li>
<li>因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的，这些类很规范的重写了hashCode()以及equals()方法</li>
</ul>
<h3 id="12-为什么Map桶中节点个数超过8才转为红黑树？"><a href="#12-为什么Map桶中节点个数超过8才转为红黑树？" class="headerlink" title="12. 为什么Map桶中节点个数超过8才转为红黑树？"></a><strong>12. 为什么Map桶中节点个数超过8才转为红黑树？</strong></h3><p>  8作为阈值作为HashMap的成员变量，在源码的注释中并没有说明阈值为什么是8</p>
<p>  在HashMap中有这样一段注释说明，我们继续看</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line"> * use them only when bins contain enough nodes to warrant use</span><br><span class="line"> * (see TREEIFY_THRESHOLD). And when they become too <span class="title function_">small</span> <span class="params">(due to</span></span><br><span class="line"><span class="params"> * removal or resizing)</span> they are converted back to plain bins.  In</span><br><span class="line"> * usages with well-distributed user hashCodes, tree bins are</span><br><span class="line"> * rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line"> * nodes in bins follows a Poisson distribution</span><br><span class="line"> * (http:<span class="comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"> * parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line"> * threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line"> * resizing granularity. Ignoring variance, the expected</span><br><span class="line"> * occurrences of list size k <span class="title function_">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * pow(<span class="number">0.5</span>, k) /</span><br><span class="line"> * factorial(k)).</span><br></pre></td></tr></table></figure>

<p>  <strong>翻译</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点（参见TREEIFY_THRESHOLD）。</span><br><span class="line">当他们边的太小（由于删除或调整大小）时，就会被转换回普通的桶，在使用分布良好的hashcode时，很少使用树箱。</span><br><span class="line">理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span><br><span class="line">第一个值是：</span><br><span class="line"></span><br><span class="line"> * <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"> * <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"> * <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"> * <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"> * <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"> * <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"> * <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"> * <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"> * <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line"> * more: less than <span class="number">1</span> in ten million</span><br></pre></td></tr></table></figure>

<p>  树节点占用空间是普通Node的两倍，如果链表节点不够多却转换成红黑树，无疑会耗费大量的空间资源，并且在随机hash算法下的所有bin节点分布频率遵从泊松分布，链表长度达到8的概率只有0.00000006，几乎是不可能事件，所以8的计算是经过重重科学考量的</p>
<ul>
<li>从平均查找长度来看，红黑树的平均查找长度是logn，如果长度为8，则logn&#x3D;3，而链表的平均查找长度为n&#x2F;4，长度为8时，n&#x2F;2&#x3D;4，所以阈值8能大大提高搜索速度</li>
<li>当长度为6时红黑树退化为链表是因为logn&#x3D;log6约等于2.6，而n&#x2F;2&#x3D;6&#x2F;2&#x3D;3，两者相差不大，而红黑树节点占用更多的内存空间，所以此时转换最为友好</li>
</ul>
<h3 id="13-HashMap为什么线程不安全？"><a href="#13-HashMap为什么线程不安全？" class="headerlink" title="13. HashMap为什么线程不安全？"></a><strong>13. HashMap为什么线程不安全？</strong></h3><ul>
<li>多线程下扩容死循环。JDK1.7中的HashMap使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题</li>
<li>多线程的put可能导致元素的丢失。多线程同时执行put操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失。此问题在JDK1.7和JDK1.8中都存在</li>
<li>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题，此问题在JDK1.7和JDK1.8中都存在</li>
</ul>
<h3 id="14-计算hash值时为什么要让低16bit和高16bit进行异或处理"><a href="#14-计算hash值时为什么要让低16bit和高16bit进行异或处理" class="headerlink" title="14. 计算hash值时为什么要让低16bit和高16bit进行异或处理"></a><strong>14. 计算hash值时为什么要让低16bit和高16bit进行异或处理</strong></h3><p>  我们计算索引需要将hashCode值与length-1进行按位与运算，如果数组长度很小，比如16，这样的值和hashCode做异或实际上只有hashCode值的后4位在进行运算，hash值是一个随机值，而如果产生的hashCode值高位变化很大，而低位变化很小，那么有很大概率造成哈希冲突，所以我们为了使元素更好的散列，将hash值的高位也利用起来\</p>
<p>  <strong>举个栗子</strong></p>
<p>  如果我们不对hashCode进行按位异或，直接将hash和length-1进行按位与运算就有可能出现以下的情况</p>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405183635630.png"></p>
<p>  如果下一次生成的hashCode值高位起伏很大，而低位几乎没有变化时，高位无法参与运算</p>
<p>  <img src="https://hexo-evenff.oss-cn-hangzhou.aliyuncs.com/images/image-20220405184136615.png"></p>
<p>  可以看到，两次计算出的hash相等，产生了hash冲突</p>
<p>  所以无符号右移16位的目的是使高混乱度地区与地混乱度地区做一个中和，提高低位的随机性，减少哈希冲突</p>

      
    </div>
    

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://fengqisheng.cn">fengqisheng</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://fengqisheng.cn/2022/04/05/%E7%AE%80%E8%BF%B0HashMap/">https://fengqisheng.cn/2022/04/05/%E7%AE%80%E8%BF%B0HashMap/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      CC BY-NC-SA 3.0
    </p>
  </div>



      
      
    

    
    <div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
  
</div>

      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Java/">Java</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2022/04/06/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">索引失效场景解析</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2022/04/05/Http%E5%92%8CHttps%E7%9A%84%E5%8C%BA%E5%88%AB/">
        <span class="next-text nav-default">Http和Https的区别</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC81NjYzMC8zMzA5Mw">
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>  
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:2250377639@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a target="_blank" rel="noopener" href="https://github.com/evenff" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
   <!--
   <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2022 - 
    
	 -->
    2023

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">fengqisheng</span>
  </span>
 
  <!--
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">post.totalcount&#58;</span>
    
    <span title="post.totalcount">18.4k</span>
  
</div>









-->

</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  
   <script type="text/javascript">
	(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>




    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script>

 
    
    <script src="/js/cursor/cherry.js"></script>
  
  </body>
</html>
